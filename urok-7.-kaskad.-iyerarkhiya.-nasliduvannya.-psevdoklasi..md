---
description: Саме тут перемагає останній!
---

# Урок 7. Каскад. Ієрархія. Наслідування. Псевдокласи.

### Мета

* вивчити, що таке каскад
* навчитися вираховувати вагу селекторів
* розвивати навички використання псевдокласів
* виховувати вміння дотримуватися порядку та ієрархії в коді

### І. Організація навчального процесу

Перевірка готовності учнів до уроку. Відповіді на запитання учнів. Налагодження діалогу.

### ІІ. АОЗ

1. Яким способом варто підключати стилі до розмітки?
2. Пригадайте повну структуру та синтаксис CSS-правила.
3. Які селектори ви пам'ятаєте з минулого уроку?
4. В чому різниця між дочірнім селектором та селектором нащадка?

### ІІІ. Повідомлення теми, мети та завдань уроку

На цьому уроці ми дізнаємося, чому таблиці стилів називають каскадними, яка вага кожного селектора та як можна застосовувати псевдокласи і псевдоелементи. Ми навчимося використовувати нові знання на практиці.

### IV. Мотивація

Зрозумівши основну суть ієрархії в CSS ви легко зможете писати лаконічний та валідний код втричі швидше.

### V. Повідомлення нового матеріалу

Каскадність CSS - це механізм, завдяки якому до будь-якого елемента HTML-документу може застосовуватися більш ніж одне правило CSS. Правила можуть йти з різних джерел: зовнішньої та внутрішньої таблиці стилів, механізму наслідування, від батьківських тегів, класів, ID, від атрибута style і т.д.

Оскільки в таких випадках часто відбувається конфлікт стилів, була створена система пріоритетів: в кінці кінців застосовується той стиль, який іде від джерела із більшим пріоритетом.

#### **Специфічність \("вага" селектора\):**

| Селектор | Вага селектора |
| :--- | :--- |
| Селектор тега \(tag name\): | 1 |
| Селектор класу \(class\): | 10 |
| Селектор ID: | 100 |
| Inline-стиль: | 1000 |

Коли селектор складається із декількох інших селекторів, необхідно порахувати їх загальну вагу. За кожен селектор додається 1 у відповідну комірку. В інших комірках стоять нулі. Щоб отримати загальну вагу, необхідно об'єднати всі числа в комірках.

| Селектор | ID | Клас | Тег | Загальна вага |
| :--- | :--- | :--- | :--- | :--- |
| p | 0 | 0 | 1 | 1 |
| .class | 0 | 1 | 0 | 10 |
| p.class | 0 | 1 | 1 | 11 |
| \#id | 1 | 0 | 0 | 100 |
| \#id p | 1 | 0 | 1 | 101 |
| \#id .class | 1 | 1 | 0 | 110 |
| p a | 0 | 0 | 2 | 2 |

{% hint style="info" %}
Чим нижче заходиться селектор по коду, тим вища його вага!
{% endhint %}

```text
p {
    font-size: 20px;
}

p {
    font-size: 22px;    /* вага даного селектора вища */
}
```

Якщо вийшло так, що два селектори мають однакову вагу, то пріоритет надається тому стилю, що знаходиться нижче по коду. Якщо для одного елементу задано стиль і в зовнішній таблиці і у внутрішній, то пріоритет надається знову тій, що знаходиться нижче по коду.

Наприклад, у внутрішній таблиці задано червоний колір для тегів `<p>`, а в зовнішній -- зелений колір для цих же тегів. В HTML-документі ви спершу підключили зовнішній файл, а потім додали внутрішню таблицю за допомогою тега `<style>`. В результаті колір тегів `<p>` буде червоним. Це один із способів управління значимістю стилів.

Ще один спосіб підвищити пріоритет -- навмисно збільшити вагу селектора, наприклад, додавши йому ID або клас.

#### Правило !important

**`!important`** - найвищий пріоритет. Якщо ви зіткнулись із екстреним випадком і вам необхідно підвищити значимість будь-якої властивості, можна додати до її оголошенні правило `!important`.

```text
h3 {
    font-size: 20px !important;
}

h3 {
    font-size: 16px;
}
```

> `!important` перекриває inline-стилі. Але занадто часте використання !important більшість розробників не підтримують. Таке оголошення прийнято використовувати лише тоді, коли конфлікт стилів не можна побороти іншим способом.

#### Комбінування та групування селекторів

Для найбільш точного вибору елементів для форматування можна використовувати комбінації селекторів. Наприклад:

```text
a[href][title] { /* така властивість спрацює тільки для посилань, */
    color: red;  /* які одночасно містять атрибути href та title */
}
```

Одні й ті ж властивості можна застосовувати одночасно для декількох елементів. Для цього, треба перелічити потрібні селектори через кому.

```text
p,
span {
    color: black;
}
```

#### Ієрархія селекторів

Пропуск в селекторі визначає відношення батьківський тег/дочірній. Скажімо, ми хочемо, щоб всі посилання в шапці сайту були червоного кольору:

```text
header a {
    color: red;
}
```

Таке правило можна читати справа наліво як: "обрати всі теги `<a>`, які знаходяться всередині елемента `<header>`". Таким чином, всі інші посилання, поза шапкою сайту, залишаться незмінними.

{% hint style="info" %}
Чим довший рядок селекторів, тим довше CSS-правило обробляється браузером. Тому, прийнято об'єднувати не більше 3 селекторів у групу.
{% endhint %}

#### Наслідування

**Наслідування в CSS** -- це механізм, за допомогою якого значення властивостей батьківського елемента передаються його нащадкам -- дочірнім елементам. Стилі, присвоєні одному елементу, наслідуються всіма його нащадками \(вкладеними елементами\), але тільки в тому випадку, якщо вони десь заново не присвоєні.

Якщо ми пропишемо наступний код в таблицю стилів:

```text
body {
    color: #913D88;
    font-size: 16px;
    border: 1px solid #333;
}
```

, то можемо помітити, що текст на веб-сторінці прийме вказаний колір та розмір шрифта. Але границя з'явиться тільки у тіла сайту &lt;body&gt;. 

Справа в тому, що згідно специфікації є властивості. які **наслідуються** --  `color`, `font`, `letter-spacing`, `line-height`, `list-style`, `text-align`, `text-indent`, `text-transform`, `visibility`, `white-space` і `word-spacing`, та ті, що **не наслідуються** --  `background`, `border`, `display`, `float` і `clear`, `height` і `width`, `margin`, `min-max-height` і `-width`, `outline`, `overflow`, `padding`,`position`, `text-decoration`, `vertical-align` і `z-index`.

За допомогою значення inherit можна змусити елемент наслідувати будь-які властивості батьківського елемента. Це працює навіть для тих властивостей, що не наслідуються за замовчуванням. Наприклад:

```text
body {
    color: #913D88;
    font-size: 16px;
    border: 1px solid #333;
}

p {
    border: inherit;
}
```

Такий підхід зручний тим, що достатньо внести виправлення тіль у властивостях елемента `<body>`, а на елемент `<p>` витрачати час не доведеться.

#### Псевдокласи

Псевдоклас в CSS -- це ключове слово, додане до селектора, яке визначає його особливий стан. Наприклад :hover може бути використаний для зміни фону блоку при наведенні курсора на нього.

```text
div:hover {
  background-color: #F89B4D;
}
```

Доступні псевдокласи:

* **:link** — не відвідане посилання;
* **:visited** — відвідане посилання;
* **:hover** — будь-який елемент, на який навели курсор миші;
* **:focus** — інтерактивний елемент, до якого перейшли за допомогою клавіатури або безпосередньо натиснули ЛКМ;
* **:disabled** — заблоковані поля форм, тобто ті, що знаходяться в неактивному стані;
* **:not\(селектор\)** — елементи, які не містять вказаний селектор -- клас, ідентифікатор, назву чи тип поля форми — **:not\(\[type="submit"\]\)**;
* **:checked** — виділені \(обрані користувачем\) елементи форми.

Структурні псевдокласи

В CSS3 існує ряд псевдокласів для роботи з дочірніми елементами. Нижче наведено пояснення кожного з них, приклади використання, а також відмінності між псевдокласами типу «child» і «of-type»:

* **:nth-child\(odd\)** — парні дочірні елементи;
* **:nth-child\(even\)** — непарні дочірні елементи;
* **:nth-child\(3n\)** — кожен третій елемент серед дочірніх;
* **:nth-child\(n+2\)** — обирає всі елементи, починаючи з другого;
* **:nth-child\(-n+2\)** - навпаки, обирає перші два;
* **:nth-child\(3\)** — обирає третій дочірній елемент;
* **:first-child** — дозволяє оформити тільки перший дочірній елемент тега;
* **:last-child** — дозволяє оформити тільки останній дочірній елемент тега;
* **:only-child** — обирає елемент, що є єдиним дочірнім тегом;
* **:empty** — обирає елементи, які не мають дочірніх тегів;

{% hint style="info" %}
Потренуватися у використанні структурних псевдокласів [можна тут](https://css-tricks.com/examples/nth-child-tester/)
{% endhint %}

### VI. Узагальнення та систематизація знань

* В чому полягає каскадність стилів?
* Яку вагу матиме група селекторів `#top p`?
* Які властивості наслідуються, а які - ні?
* Як можна застилити тільки перший дочірній елемент тега?
* Як вибрати кожен другий дочірній елемент тега?
* Як можна змінити стан елементе при наведенні на нього курсора миші?

### VII. Домашнє завдання

Ви маєте вихідний код розмітки, який не можна змінювати. Стилізуйте елементи згідно їх вмісту.

```text
<div class="text-box">
    <h3>Пофарбуйте мене в рожевий колір (color:pink).</h3>
    <p>Даний елемент має залишитись неоформленим.</p>
    <p id='greycol'>Пофарбуйте мене в сірий колір (color:grey).</p>
    <div>Даний елемент має залишитись неоформленим.</div>
    <div><p>Пофарбуйте мене в червоний колір (color:red).</p></div>
    <h3>Даний елемент має залишитись неоформленим.</h3>
    <p>Пофарбуйте мене в зелений колір (color:green).</p>
    <p class='yellow'>Пофарбуйте мене в жовтий колір (color:yellow).</p>
</div>
```

